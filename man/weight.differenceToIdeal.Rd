% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/WeightFunctions.R
\name{weight.differenceToIdeal}
\alias{weight.differenceToIdeal}
\title{Calculates attribute weights using the 'objective approach'}
\usage{
weight.differenceToIdeal(dataset, userid = NULL, attr = NULL,
  rounds = "all", cost_ids = NULL)
}
\arguments{
\item{dataset}{data.frame with the user generated data from a product
configurator. See \code{decisionMatrix} for specifications of the dataset.}

\item{userid}{a vector of integers that gives the information of which users
the matrix should be calculated. Vectorised.}

\item{attr}{attributes IDs, vector of integer numbers corresponding to the
  attributes you desire to use; attr are assumed to be 1-indexed. This
  function will calculate with all attributes and do the subsetting a
  posteriori.

  If you want to get the weights for only two attributes you will have to
  first use \code{\link{decisionMatrix}} and then pass it on to
  \code{\link{normalize.altMethod}} and \code{\link{differenceToIdeal}}.}

\item{rounds}{integer vector or text option. Which steps of the configuration
process should be taken into account? Defaults are "all" in order to have
more data to calculate with. If \code{"first"} or \code{"last"} are entered
there will be only one rounds to gather data from, consequently all
attribtues will have the same weight.}

\item{cost_ids}{argument used to convert selected cost attributes into
benefit attributes. Integer vector. This functions uses an alternative
normalizing method \code{\link{normalize.altMethod}} that does not produce
negative values.}
}
\value{
a list of weight vector(s)
}
\description{
This function first normalizes a list of matrices and then calculates the
decision weight for each attribute, using the 'objective approach' as given
by [1] and [2]. The objective approach, in this case, uses only data gathered
from the decision matrix and it does not need a 'subjective' preference
matrix from the decision maker. The sum of a weight vector should always
equal 1.
}
\details{
The result is a list of vectors, each vector with the same length as the
number of columns of the input matrices, i.e. each column gets a weight.

This function rewards attributes which values do not change much
  throughtout the decision matrix, even if the value is the lowest value for
  that attribute. For an opposite implicit effect see
  \code{\link{weight.entropy}}

  \code{cost_ids} As in the other functions, if you enter a cost_ids that is
  not in your entered attributes, the functions will calculate the output
  with all attributes in your data, including the cost(s) attributes and only
  after the calculations does the function subset the result according to the
  \code{attr}. When the attributes and cost_ids differ, the function allows
  the calculation but it will throw a warning.
}
\examples{
# Not runnable yet
weight.differenceToIdeal(myData, 15:22)
weight.differenceToIdeal(laptop_data, 40:45, attr= c(1, 3, 4), cost_ids = 4)
savedWeights <- weight.differenceToIdeal(myData, c(6, 15, 18, 20, 26), attr = 1:4, cost_ids = 4, rounds=1:8)
lapply(savedWeights, sum) # Should return 1 for any output of this function

}
\references{
[1]Ma, J., Fan, Z. P., & Huang, L. H. (1999). A subjective and
  objective integrated approach to determine attribute weights. European
  journal of operational research, 112(2), 397-404. [2] Fan, Z. P. (1996).
  Complicated multiple attribute decision making: theory and applications
  (Doctoral dissertation, Ph. D. Dissertation, North-eastern University,
  Shenyang, PRC).
}

