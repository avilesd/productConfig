% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TRPFunctions.R
\name{overallPV_interface}
\alias{overallPV_interface}
\title{cost_ids, enter normal reference points, we will convert them. cost_ids has to equal the attribute you are inputting
DOCU: Converting tri.refps, no need to convert if attribute is of type cost.
New function as interface with weights and your trp.valueMatrix
Docu: For the way the trp function works it is a little more complicated than for overallPV for the pt
here we have to manually calculate the AttributeWeights whit your desired function, e.g ww <- getAttrWeights(...)
and the trp.ValueMatrix separately as well, trp.VM <- mapply() OR trpValueMatrix(...)
then giving to this function as input and getting the desired result}
\usage{
overallPV_interface(trp.ValueMatrix, weight = NULL)
}
\arguments{
\item{trp.ValueMatrix}{generally a \emph{list} of matrices from different
users, such as the output of \code{\link{trpValueMatrix}}. One matrix is
accepted as input but it will be coerced to a list.}

\item{weight}{generally a \emph{list} of weights from different users, such
as the output of \code{\link{getAttrWeights}}. One vector is also accepted,
if there are more than one matrices, the function will try to recycle the
weight vector.}
}
\value{
a (list of) vector(s) of overall prospect values
}
\description{
DOCU: Explain what _extends is in pC, singalizes major functions that do not take the normal inputs but user
other functions' results to work.
Runs a simple additive weighting function over matrices
}
\details{
Auxiliary function: Takes a matrix and a numeric vector and returns the
overall weighted values for each row of the matrix by means of a simple
additiv weighting function.

The columns of the matrix should be different attributes of a
  product or setup and the weight vector should contain a numeric value for
  each attribute, so that \code{ncol(trp.ValueMatrix)=length(weight)}. Both
  parameters are vectorised so you can enter a list of matrices in
  \code{trp.ValueMatrix} and a list of vector in \code{weight}. A matrix in
  the first argument or a vector in the second will be coerced into a list.

  If some elements of the output list are called \code{$<NA>}, then try to
  avoid recycling by checking your \code{weight} input.
}
\examples{
#Runnable
overallPV_interface(trp.ValueMatrix = matrix(1:8, 2, 4), weight = c(0.25, 0.3, 0.15, 0.3))
overallPV_interface(matrix(1:32, 16, 2), c(0.72, 0.25))
overallPV_interface(list(m1 = matrix(1:32, 16, 2), m2 = matrix(1:14, 7, 2)),
                         weight = c(100, 200)) # weight will be recycled: used on both matrices
overallPV_interface(list(m1 = matrix(1:32, 16, 2), m2 = matrix(1:14, 7, 2)),
                         list(weight1 = c(100, 200), weight2 = c(20, 50)))

#Not Runnable
overallPV_interface(aLargeListOfMatrices, weight = c(0.1, 0.2, 0.62, 0.05, 0.03))
overallPV_interface(aLargeListOfMatrices, aLargeListOfVectors) #both arguments should have equal length
}

