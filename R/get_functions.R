#' Extract the part of the provided dataset that corresponds to a user id.
#'
#' We assume the given dataset was generated by data from a product configuration,
#' and therefore has as one column the user id. Other columns may include, but not limited to, attribute IDs, round,
#' selected attribute and selectable attribute. With user_id you select the rows, all given columns of x remain intact.
#'
#' @param x the data set (table) you want to analize and separate in smaller data sets.
#'
#' @param user_id an integer, that identifies which rows of the whole given dataset (x) should be extracted.
#' @return A data frame with the same columns as the original, but only with rows about the provided \code{user_id}.
#' @examples
#' get_table_by_ID(camera2_config_data, 9)
#' @export
#'

get_table_by_ID<- function(x, userid,...) {
  result <- x[x$usid == userid, ]
  result
}


#' Count the number of attributes
#'
#' Description (pending all but title)
#'
#' @param x the data set (table) you want to analize and separate in smaller data sets.
#'
#' @param
#'
#' @return a vector
#' @examples
#' get_table_by_ID(camera2_config_data, 9)
#' @export
#'

get_attrs_ID<- function(x) {
  help <- lapply(x, unique)
  result <- help$atid

  if(!is.vector(result) & class(result) != "integer") {
    warning("Result of function not a vector of integers, attributes IDs should be integers.")
  }

  result
}


get_rounds_by_ID <- function(x, userid) {
  table_by_ID <- get_table_by_ID(x, userid)
  result <- unique(table_by_ID$round)
  result
}

get_all_userids <- function(dataset) {
  table_unique <- sapply(play_data, unique)
  result <- table_unique$usid
  result
}

get_all_default_rps <- function(dataset, userid) {
  table_unique <- get_table_by_ID(dataset, userid)
  table_0 <- table_unique[table_unique$round == 0, ]
  result <- table_0$selected

  ##Give Reference Points names according to attribute they belong to
  m <- 1
  rp_names <- character(0)
  for(rp in result){
    rp_names <- c(rp_names, paste("rp", m, seq="", collapse=""))
    m <- m + 1
  }
  names(result) <- rp_names

  result

}

get_normalized_vec <- function(num_vector) {
  if(is.vector(num_vector, mode="numeric")) {
    sum <- sum(num_vector)
    result <- num_vector/sum
    result
  }
  else warning("Entered argument not a numeric vector.")
}


# This is just a funcion that I wrote here to not forget the code, could be useful, but right now is not fundamental.
read_attr_levels <-function(x) {
  help1 <- tapply(x$selected, play_data$atid == 4, unique)
  result <- help1$'TRUE'
  result
}


## To be use for weights.
#'
#' @param rel_frequeny logical. Relative frequency, if \code{rel_frequency = TRUE}, the function ignores the refps argument
#'        and calculates the aspiration level for each attribute as the relative frequency the user made for that attribute.
#'
#' ###to consider, defaults considers all your attributes in your table and calculates with relative frequency of the attributes
#' if no other weights are given. ##no userid because weights independent from user
#'
get_attr_weight <- function(dataset) {
  if(is.null(dataset) ) {
  refps <- get_all_default_rps(dataset, userid)
  ##TODO calculate relative frequency, see annotations notebook
  }
  ## TODO proove if length(w) =length(attributes), proof if numeric and the sum of all = 1!!!
  else{
    weight
  }
}

