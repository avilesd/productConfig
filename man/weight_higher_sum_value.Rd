% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/weight_functions.R
\name{weight_higher_sum_value}
\alias{weight_higher_sum_value}
\title{Weights based on the sum of attribute values}
\usage{
weight_higher_sum_value(dataset, userid = NULL, rounds = NULL,
  cost_ids = NULL)
}
\arguments{
\item{dataset}{data.frame with the user generated data from a product configurator. See Details
 for the specifications of the data.frame.}

\item{userid}{an integer that gives the information of which user you want the data from: User ID.}

\item{rounds}{integer vector. Does not play a role at this moment (<= 0.2.0.9000) in this function, but it does for future improvements.}

\item{cost_ids}{argument used to convert selected cost attributes into benefit attributes. Integer vector.}
}
\value{
Relative weights for all attributes
}
\description{
This weight function sums all attribute values for all available rounds. The higher the sum for one attribute, the better it will be weighted.
After getting the sum for each attribute, the results will be normalized resulting in all weights being smaller than 1 and the sum of all weights
equaling 1. Typically used within this package to calculate weights when the user has not given any in \code{\link{get_attr_weight}}
}
\details{
This function does not handle different amount of attributes, it always calculates weights for all attr. The filtering
according to the user's input happens in \code{\link{get_attr_weight}}

One problem of this function as it is (<= 0.2.0.9000) is that it works mostly assuming that the attribute values
across all attributes have the same maximum and minimum value, so that a comparison of the sum of each attribute values makes sense.
In the data we worked building this package, there is already a problem with this since three attributes work with {0,1,2,3} values
and a forth works with values between [0,1]. For our package we found a solution, but it is necessary to implement a more general
solution.

\code{cost_ids} It handles it well, by adding all together and treating it as cost and then just using abs() to get the positive value.
Default assumes all your attributes are of benefit type, that is a higher value in the attribute means the user
is better of than with a lower value. If one or more of the attributes in your data is of cost type, e.g. price, so that lower is better then you should identify
this attributes as such, providing their id, they'll be converted to benefit type (higher amount is better).

If you want to know more about the other parameters, e.g. \code{dataset}, look at \code{powerful_function}.
}
\examples{
weight_higher_sum_value(pc_data, 11)
weight_higher_sum_value(my_data, userid = 1000, cost_ids = 4)
weight_higher_sum_value(monitor_data, 50)
weight_higher_sum_value(data1, 8, cost_ids = c(1,3))
}
\seealso{
Other weight functions: \code{\link{get_attr_weight}}
}

