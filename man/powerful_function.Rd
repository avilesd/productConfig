% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerful_function.R
\name{powerful_function}
\alias{powerful_function}
\title{Takes one function and runs it for more than one user}
\usage{
powerful_function(dataset, userid = NULL, FUN = decision_matrix,
  attr = NULL, rounds = NULL, refps = NULL, cost_ids = NULL,
  weight = NULL, alpha = 0.88, beta = 0.88, lambda = 2.25,
  gainm = TRUE, result_type = NULL)
}
\arguments{
\item{dataset}{data.frame with the user generated data from a product
configurator. See Details for the specifications of the data.frame.}

\item{userid}{an integer that gives the information of which user you want
the data from: User ID.}

\item{FUN}{Name of the function within the package you want to use. Input
without "".}

\item{attr}{attributes IDs, vector of integer numbers corresponding to the
attributes you desire to use; attr are assumed to be 1-indexed.}

\item{rounds}{integer vector. Which steps of the configuration process should
be shown? See Details.}

\item{refps}{numeric vector. Reference Points: each point corresponds to one
attribute, i.e. each attribute has only one aspiration level. Default
setting assumes the aspiration levels as the default values of the initial
product configuration for each user.}

\item{cost_ids}{argument used to convert selected cost attributes into
benefit attributes. Integer vector.}

\item{weight}{orders each attribute a weight <= 1 for the value functions to
assign a value to each alternative or in the case of productConfig, to each
round.}

\item{alpha}{numeric between [0, 1]. Determines the concativity of the value
function as given by Reference [1].}

\item{beta}{numeric between [0, 1]. Determines the convexity of the value
function as given by Reference [1].}

\item{lambda}{lambda > 1. Parameter of loss aversion for the value function
as given by Reference [1].}

\item{gainm}{loading...}

\item{result_type}{allows to change the result type. Default returns a list
with two elements. Other possibilites are "cbind" and "rbind" as character
input which do exactly what their name suggests; return a column- or row-
binded matrix. Only for \code{gain_loss_matrices} function.}
}
\value{
The same value that returns the function you entered in \code{FUN}
  for the users you entered in the \code{userid} parameter.
}
\description{
Provides a way to run a function \code{FUN} for more users at once.Almost all
other functions in this package are built so that you get the data you need
for one specific user only at a time. The powerful_functionallows you to run
almost all other functions in this package with the same parameters you are
used to use, but for more users at once. The difference being that for
\code{userid} you can now enter just one ID or a vector of IDs contained in
your data.
}
\details{
If you enter more parameters that a given function needs, the function will
just take the parameters it needs and ignore the extra ones. Important is
that you understand, the parameters of the function are passed on to other
functions of the package, so the following description of parameters applies
to the functions you are going to input in the \code{FUN} parameter, rather
than to the powerful_function itself. You can imagine this function as being
a loop-function that takes any other function and runs it for more
\code{userid}s than just one.

\code{dataset} We assume the input data.frame has following columns
usid = User IDs, round = integers indicating which round the user is in
(0-index works best for 'round'), atid = integer column for referring the
attribute ID (1 indexed), selected = numeric value of the attribute for a
specific, given round, selectable = amount of options the user can chose at a
given round, with the current configuration. This is a necessary parameter.

\code{userid} is a necessary parameter, without it you'll get a warning.
Default is NULL.

\code{FUN} Default value is "decision_matrix". Some functions you can try
\code{overall_pv gain_loss_matrices gain_matrix loss_matrix norm_g_l_matrices
decision_matrix get_attrs_ID get_table_by_ID get_rounds_by_ID ref_points}

\code{rounds} Default calculates first round(initia product config) and last
round of the session. Default calculates with first and last attributes
(initial and final product configuration). To choose all give "all" as
argument for rounds, see example. "first" and "last" are also possible
argument values. You can give a vector of arbitrarily chosen rounds as well.

\code{refps} If you only want to see the results for one attribute you may
enter only a couple of reference points but you have to tell the function
which attributes you want to use those referene points for. So the amount of
attr and of refps should be the same. Moreover the functions always orders de
attr, so be sure to input the reference point also in an ascending order
corresponding to their attributes. (refps will not be ordered)

\code{cost_ids} Default assumes all your attributes are of benefit type, that
is a higher value in the attribute means the user is better of than with a
lower value. If one or more of the attributes in your data is of cost type,
e.g. price, so that lower is better then you should identify this attributes
as such, providing their id, they'll be converted to benefit type (higher
amount is better).

\code{weight}

\code{alpha} Default value as given by Reference [1] is 0.88

\code{beta} Default value as given by Reference [1] is 0.88

\code{lambda} Default value as given by Reference [1] is 2.25
}
\examples{
powerful_function(data_camera, 2)  # FUN=decision_matrix
powerful_function(data_pc, userid = c(1,2,4,8,9,100))
powerful_function(my_table, get_all_userids(my_table))

powerful_function(data_pc, userid = c(1,2,3), FUN = gain_matrix)
powerful_function(data_pc, userid = c(1,2,3), FUN = overall_pv, alpha = 0.9, weight=c(0.1,0.2,0.5,0.2))
powerful_function(datadata, c(6,9), FUN = ref_points) # Returns the default values for both users (user6, user9) assumed as reference points.

}

