% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/WeightFunctions.R
\name{weight.entropy}
\alias{weight.entropy}
\title{Calculates decision weights using the entropy method}
\usage{
weight.entropy(dataset, userid = NULL, attr = NULL, rounds = "all",
  cost_ids = NULL)
}
\arguments{
\item{dataset}{data.frame with the user generated data from a product
configurator. See \code{decisionMatrix} for specifications of the dataset.}

\item{userid}{a vector of integers that gives the information of which users
the matrix should be calculated. Vectorised.}

\item{attr}{attributes IDs, vector of integer numbers corresponding to the
  attributes you desire to use; attr are assumed to be 1-indexed. This
  function will calculate with all attributes and do the subsetting a
  posteriori.

  If you want to get the weights for only two attributes you will have to
  first use \code{\link{decisionMatrix}} and then pass it on to
  \code{\link{normalize.sum}} and \code{\link{entropy}}.}

\item{rounds}{integer vector or text option. Which steps of the configuration
process should be taken into account? Defaults are "all" in order to have
more data to calculate with. If \code{"first"} or \code{"last"} are entered
there will be only one rounds to gather data from, consequently all
attribtues will have the same weight.}

\item{cost_ids}{argument used to convert selected cost attributes into
benefit attributes. Integer vector. This functions uses an alternative
normalizing method \code{\link{normalize.sum}} that does not produce
negative values. However, it has one limitation, if within a same attribute
there are negative and positive values, the function will likely produce a
\code{NaN}.}
}
\value{
a list of weight vector(s)
}
\description{
This function first normalizes a list of matrices and then calculates the
decision weight for each attribute, using an entropy approach [1, 2], which
can be categorised as an objective approach, just as
\code{\link{weight.differenceToIdeal}}. This type of weight functions use
only the information within the decision matrix to calculate weights. It does
not need information about the decision maker's preferences.
}
\details{
The result is a list of vectors, each vector with the same length as the
number of columns of the input matrices, i.e. each column gets a weight. The
sum of a weight vector should always equal 1.

In contrast to \code{\link{weight.differenceToIdeal}}, this function
  distributes lower weights to those attributes, which have similar values
  throughout the decision matrix.

  Note: the normalizing function used here \code{\link{normalize.sum}} has
  one limitation, if within a same attribute there are negative and positive
  values, the function will likely produce a \code{NaN}.

  \code{cost_ids} As in the other functions, if you enter a cost_ids that is
  not in your entered attributes, the functions will calculate the output
  with all attributes in your data, including the cost(s) attributes and only
  after the calculations does the function subset the result according to the
  \code{attr}. When the attributes and cost_ids differ, the function allows
  the calculation but it will throw a warning.
}
\examples{
# Not runnable yet
weight.entropy(myData, 15:22)
weight.entropy(laptop_data, 40:45, attr= c(1, 3, 4), cost_ids = 4)
savedWeights <- weight.entropy(myData, c(6, 15, 18, 20, 26), attr = 1:4, cost_ids = 4, rounds=1:8)
lapply(savedWeights, sum) # Should return 1 for any output of this function

}
\references{
[1]Hwang, C. L., & Yoon, K. (2012). Multiple attribute decision
  making: methods and applications a state-of-the-art survey (Vol. 186).
  Springer Science & Business Media.

  [2]Shannon, C. E. (2001). A mathematical theory of communication. ACM
  SIGMOBILE Mobile Computing and Communications Review, 5(1), 35.

  [3]Lotfi, F. H., & Fallahnejad, R. (2010). Imprecise Shannonâ€™s entropy and
  multi attribute decision making. Entropy, 12(1), 53-62.
}

