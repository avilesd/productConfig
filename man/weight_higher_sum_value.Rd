% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/weight_functions.R
\name{weight_higher_sum_value}
\alias{weight_higher_sum_value}
\title{Weights based on the sum of attribute values}
\usage{
weight_higher_sum_value(dataset, userid = NULL, attr = NULL,
  rounds = NULL, cost_ids = NULL)
}
\arguments{
\item{dataset}{data.frame with the user generated data from a product configurator. See Details
 for the specifications of the data.frame.}

\item{userid}{an integer that gives the information of which user you want the data from: User ID.}

\item{attr}{attributes IDs, vector of integer numbers corresponding to the attributes you desire to use; attr are assumed to be 1-indexed.}

\item{rounds}{integer vector. Which steps of the configuration process should be shown? See Details.}

\item{cost_ids}{argument used to convert selected cost attributes into benefit attributes. Integer vector.}
}
\value{
a
}
\description{
This weight function sums all attribute values for all available rounds. The higher the sum for one attribute, the better it will be weighted.
After getting the sum for each attribute, the results will be normalized resulting in all weights being smaller than 1 and the sum of all weights
equaling 1.
}
\details{
One problem of this function as it is (<= 0.2.0.9000) is that it works mostly assuming that the attrbute values
across all attributes have the same maximum and minimum value, so that a comparison of the sum of each attribute values makes sense.
In the data we worked building this package, there is already a problem with this since three attributes work with {0,1,2,3} values
and a forth works with values between [0,1]. For our package we found a solution, but it is necessary to implement a more general
solution.

\code{cost_ids} It handles it well, by adding all together and treating it as cost and then just using abs() to get the positive value.

If you want to know more about the other parameters, look at \code{gain_matrix loss_matrix decision_matrix}.
}
\examples{
norm_g_l_matrices(pc_config_data, 11)
norm_g_l_matrices(my_data, userid = 11, result_type = "cbind")
norm_g_l_matrices(monitor_data, 50, rounds = "last", refps = c(0.1,0.3,0.4,0.5), cost_ids = 3)
norm_g_l_matrices(data1, 8, attr = 1)
}

