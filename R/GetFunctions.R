#' Extract the part of the provided dataset that corresponds to a user id.
#'
#' With \code{userid} you select the rows from one user, all given columns of
#' \code{dataset} remain intact for that user. We assume the given dataset was
#' generated by data from a product configurator, and therefore has at least one
#' column with users' ids. Other columns may include, but are not limited to,
#' attribute IDs, round, selected attribute and selectable attribute.
#'
#' @param dataset the data.frame (table) you want to separate in a smaller
#'   data.frame for a specific user.
#'
#' @param userid an integer vector, that identifies which rows (from which user) of
#'   the whole given dataset should be extracted. This parameter is vectorised,
#'   you may enter more \code{userid} at once.
#' @return A named list of data.frames with the same columns as the original
#'   data.frame, but the information on the rows are only for each user.

#'
#' @family GetFunctions
#'
#' @examples #Not Runnable yet
#' getTableById(camera_data, 9:25)
#' getTableById(as.data.frame(matrix_full), 12)
#' @export

getTableById <- function(dataset, userid = NULL,...) {
  if(is.null(userid)) {
    stop("You need to specify at least one userid.")
  }

  if(FALSE %in%(userid %in% getAllUserIds(dataset))) {
    logicalVector <-!(userid %in% getAllUserIds(dataset))
    fatalUserid <- userid[logicalVector]
    fatalUserid <- paste(fatalUserid, collapse = " ")
    stop("At least one userid you specified is not contained within your data: ", fatalUserid)
  }

  result <- split(dataset, f = dataset$usid)
  result <- result[as.character(userid)]
  result
}

#' Get the amount of attributes and their IDs
#'
#' Allows the user to know how many different attributes there are in the
#' data.frame or table. The number of attributes comes directly from the number
#' of categories that a user can manipulate in a given product configurator. The
#' function assumes that all attribute IDs are in a single column with the name
#' \code{$atid}. It also assumes, that all users interacted with the same amount
#' of attributes.
#'
#' @param dataset the data.frame you want to input.
#'
#' @return a vector of integers representing all existing attribute IDs.
#'
#' @family GetFunctions
#'
#' @examples
#' get_attrs_ID(my_data) #Example return: [1] 1 2 3 4 , meaning there are 4 attributes on my_data with ascending indexes.
#' get_attrs_ID(bad_data)
#' @references ProductConfig Github page:
#'   https://github.com/avilesd/productConfig
#' @export

get_attrs_ID <- function(dataset) {
  help <- lapply(dataset, unique)
  result <- help$atid

  if(!is.vector(result) & class(result) != "integer") {
    warning("Result of function not a vector of integers, attributes IDs should only be integers.")
  }
  result <- sort(result)
  result
}

#'Get the amount of rounds (clicks) for each user
#'
#'Allows to calculate the amount of times a user interacted with the product
#'configurator, i.e. amount of clicks for any given \code{userid}. The entered
#'data.frame should signalize this information with a column named \code{round},
#'which should only contain numeric values. Function is vectorised in
#'\code{userid}.
#'
#'@param dataset the complete data.frame. You can also input the data.frame
#'  specific for one user, such as the one generated with
#'  \code{\link{getTableById}}.
#'@inheritParams getTableById
#'
#'@return A list of integer vectors representing the index of each round/click
#'  and therefore the total amount of rounds for the selected user.
#'
#' @family GetFunctions
#'
#' @examples #Not Runnable yet
#' getRoundsById(example_data, userid = 6) # Example return: [1] 0 1 2 3 4 5 6 7 8
#' getRoundsById(as.data.frame(matrix_full), 12:10)
#'
#'@export

getRoundsById <- function(dataset, userid = NULL) {
  tablesById <- getTableById(dataset, userid)
  result <- lapply(tablesById, function(tempData) unique(tempData$round))
  result
}

#' Get all user IDs
#'
#' Allows you to get all the user IDs in your data. It assumes you have a column
#' \code{usid} that identifies each user's information for each round with its
#' corresponding user ID. Returns IDS unordered, i.e. in the order they appear
#' on the table.
#'
#' @param dataset the data.frame you want to input.
#'
#' @return a vector of integers with all user IDs. IDs are returned in the order
#'   they appear on the table.
#'
#' @family GetFunctions
#' @examples
#' getAllUserIds(example_data) #Example return: [1] 1 2 3 4 5
#' getAllUserIds(data) #Example return: [1] 6 9 10 8 6 2 4
#'
#' @references ProductConfig Github page:
#'   https://github.com/avilesd/productConfig
#' @export

getAllUserIds <- function(dataset) {
  table_unique <- sapply(dataset, unique)
  result <- table_unique$usid
  result
}
#'Get Default Reference Points for selected user
#'
#'With Default Referenece Points we mean the initial configuration of the
#'product configurator, that is the value for each attribute that was selected
#'as default before the user interacted with the configurator. It assumes there
#'is a column with the name 'round' from which to read the default values (in
#'round = 0) for each user. The  The default values of each 'category' can be
#'interpreted as possible Reference Points for the decision maker. See Source
#'for more about this assumption.
#'
#' @inheritParams getTableById
#' @param dataset the data.frame you want to input. For more details about which information
#' the dataset should have, refer to \code{\link{decisionMatrix}}.
#'
#'
#'@return A list of numeric vectors with column names representing the attribute ID each
#'  reference point belongs to.
#'
#' @family GetFunctions
#' @examples #Not Runnable yet
#' getDefaultRefps(camera2_config_data, c(6,9,10))
#' getDefaultRefps(as.data.frame(matrix_full), 55:58)
#'@export

getDefaultRefps <- function(dataset, userid = NULL) {

  tablesById <- getTableById(dataset, userid)
  tablesDefaultRound <- lapply(tablesById, function(tempData) tempData[tempData$round == 0, ])
  result <- lapply(tablesDefaultRound, function(tempData2) tempData2$selected)

  ## Get Names, depending on how many attributes and set them on a vector
  allAttr <- get_attrs_ID(dataset)
  refpsNames <- paste("rp", allAttr)

  result <- lapply(result, setNames, refpsNames)

  result

}
#' Normalize a vector
#'
#' Divide all given vectors with the absolute sum of all the elements in the
#' vector, such that the sum of the result equals 1, that is if you take the
#' absolute value of the results. In other words, you can give negative values.
#'
#' @param num_vector numeric vector you want to normalize.
#'
#' @return A normalized vector, i.e. another numeric vector with the sum of its
#'   values equaling 1.
#'
#' @family GetFunctions
#' @examples
#' normalize(c(1,2,1,2)) #Returns: [1] 0.1666667 0.3333333 0.1666667 0.3333333
#' normalize(c(1,2,-1,-2)) #Returns: [1] 0.1666667 0.3333333 0.1666667 -0.3333333
#' normalize(c(10,20,30,40,50))
#'
#' @references ProductConfig Github page:
#'   https://github.com/avilesd/productConfig
#' @export

## Renewed function , eventually to put in other R script with functional functions below
normalize <- function(num_vector) {
  if(is.vector(num_vector, mode="numeric")) {
    sum <- sum(abs(num_vector))
    result <- num_vector/sum
    result
  }
  else warning("Entered argument not a numeric vector.")
}

#' All unique values for any given attribute
#'
#' Returns all unique values that can be found in the inputed attributes, i.e. all
#' values that exist for \code{attrid} for all users.
#'
#' @param dataset complete data.frame with a \code{atid} column referring to the
#'   attribute ID.
#' @param attrid the ID(s) of the attribute(s) you want to know all unique values of.
#'
#' @return Unique values for the given attributes, applies for all users.
#'
#' @family GetFunctions
#' @examples
#' getAttrValues(example_data, attrid=1) # Example return: [1] 0 3 2 1 meaning that category only has 4 possible values in the product configutrator, or at least those were the ones the users clicked on
#' getAttrValues(other_data, 100) #Possible catched error: The attrID you specified is not contain in your data.
#'
#' @export

getAttrValues <-function(dataset, attrid = NULL) {
  if(is.null(dataset)) {
    stop("You need to provide the dataset")
  }

  allAttributes <- get_attrs_ID(dataset)

  if(is.null(attrid)) {
    attrid <- allAttributes
  }
  if(FALSE %in%(attrid %in% allAttributes)) {
    allAttributes <- paste(allAttributes, sep=",", collapse = " ")
    stop("One of the attrid you specified is not contained in your data. Valid Attibute Ids are: ", allAttributes)
  }

  help1 <- split(dataset, f = dataset$atid)
  result <- lapply(help1[attrid], function(tempData) unique(tempData$selected))
  result
}

#' Converts benefit type attributes to cost type, within a list
#'
#' @inheritParams decisionMatrix
#' @param aList a List with decision matrices as elements. Within each decision matrix, the
#' columns are attributes from a product configurator. Using \code{cost_ids} the cost type
#' attribtues are identified and transformed from benefit to cost attributes. Cost attributes are
#' product characteristics for which a lower value means a higher 'utility', e.g. price.
#'
#' @return the same list as \code{aList} with converted cost attribtues
#'
#' @family GetFunctions
#' @examples #Not runnable yet
#' benefitToCostAttr(myData, listWithDecMatrices, cost_ids= c(5,8))
#' benefitToCostAttr(myData2, someList, cost_ids= 1:3)
#' @export

#New function it can handle two types of lists, important for RefPoints and for decisionMatrix. It handles
# with list-elements as a. vectors, e.g. refps or as b. matrices like in a decision matrix.
benefitToCostAttr <- function(dataset, aList, cost_ids = NULL) {
  allAttrs <- get_attrs_ID(dataset)
  booleanVector <- cost_ids %in% allAttrs

  if(FALSE %in% booleanVector  & class(cost_ids) == "numeric") {
    attrAndCostIds <- cost_ids[!booleanVector]
    attrAndCostIds <- paste(attrAndCostIds, sep=",", collapse = " ")
    stop("some cost/attribute IDs you entered in cost_ids are not to be found in your data: ", attrAndCostIds)
  }

  if(is.null(cost_ids)) {
    costifiedList <- aList
  }
  else {
    n <- 1
    if(is.vector(aList[[1]]) & !is.list(aList[[1]])) {
      for(n in 1:length(aList)) {
        aList[[n]][cost_ids] <- aList[[n]][cost_ids]*(-1)
        costifiedList <- aList
      }
    }
    else {
      for(n in 1:length(aList)) {
        aList[[n]][,cost_ids] <- aList[[n]][,cost_ids]*(-1)
        costifiedList <- aList
      }
    }
  }
  costifiedList
}


#' Auxiliary function used for testing.
#'
#' @param x an element with numeric, logical or char values.
#' @param y an element with numeric, logical or char values.
#' @param boolean.vector containing indexes of which values should be changed.
#'
#' @return a subset of \code{x}
#'
#' @examples
#' replaceNotNA(a, b, c(T, F, T, T))
replaceNotNA <- function(x, y, boolean.vector) {
  x[boolean.vector] <- y[boolean.vector]
  x
}
