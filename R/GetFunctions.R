#' Extract the part of the provided dataset that corresponds to a user id.
#'
#' With user_id you select the rows from one user, all given columns of x remain
#' intact for that user. We assume the given dataset was generated by data from
#' a product configuration, and therefore has as one column the user id. Other
#' columns may include, but not limited to, attribute IDs, round, selected
#' attribute and selectable attribute.
#'
#' @param x the data.frame (table) you want to separate in a smaller data.frame
#'   for a specific user. For more users at once see
#'   \code{\link{powerful_function}} or manually.
#'
#' @param user_id an integer, that identifies which rows (from which user) of
#'   the whole given dataset should be extracted.
#' @return A data.frame with the same columns as the original, but only with
#'   rows about the provided \code{user_id}.
#' @seealso \code{\link{powerful_function}} allows you to run this and any other
#'   function in this package for more than one user.
#'
#' @family get functions
#'
#' @examples
#' get_table_by_ID(camera2_config_data, 9)
#' get_table_by_ID(as.data.frame(matrix_full), 12)
#' @export

get_table_by_ID<- function(x, userid = NULL,...) {
  if(is.null(userid)) {
    stop("You need to specify one userid.")
  }
  ## Check if given userid is in the data
  if(!userid %in% get_all_userids(x)) {
    print(userid)
    stop("The userid you specified is not contained in your data.")
  }

  result <- x[x$usid == userid, ]
  result
}

getTableByID <- function(dataset, userid = NULL,...) {
  if(is.null(userid)) {
    stop("You need to specify at least one userid.")
  }

  if(FALSE %in%(userid %in% get_all_userids(dataset))) {
    logicalVector <-!(userid %in% get_all_userids(dataset))
    fatalUserid <- userid[logicalVector]
    print(fatalUserid)
    stop("At least one userid you specified is not contained within your data.")
  }

  result <- split(dataset, f = dataset$usid)
  result <- result[as.character(userid)]
  result
}


#' Get the amount of attributes and their IDs
#'
#' Allows the user to know how many different attributes there are in the
#' data.frame or table. The number of attributes comes directly from the number
#' of categories that a user can manipulate in a given product configurator. The
#' function assumes that all attribute IDs are in a single column with the name
#' \code{$atid}. It also assumes, that all users interacted with the same amount
#' of attributes.
#'
#' @param x the data.frame you want to input.
#'
#' @return a vector of integers representing all existing attribute IDs.
#'
#' @family get functions
#'
#' @examples
#' get_attrs_ID(my_data) #Example return: [1] 1 2 3 4 , meaning there are 4 attributes on my_data with ascending indexes.
#' get_attrs_ID(bad_data) #Warning: Attributes IDs should only be integers.
#' @references ProductConfig Github page:
#'   https://github.com/avilesd/productConfig
#' @export
#'

get_attrs_ID <- function(dataset) {
  help <- lapply(dataset, unique)
  result <- help$atid

  if(!is.vector(result) & class(result) != "integer") {
    warning("Result of function not a vector of integers, attributes IDs should only be integers.")
  }

  result
}

#'Get the amount of rounds (clicks) for one user
#'
#'Allows to calculate the amount of times a user interacted with the product
#'configurator, i.e. amount of clicks for the given user ID. The given
#'data.frame should signalize with a column named 'round', which should only
#'contain numbers.
#'
#'@param x the complete data.frame. You can also input the data.frame specific
#'  for one user, such as the one generated with \code{\link{get_table_by_ID}}.
#'  For more users at once see \code{\link{powerful_function}} or manually.#'
#'@param userid an integer, that identifies which rows (from which user) of the
#'  whole given dataset should be extracted.
#'
#'@return An integer vector representing the index of each round/click and
#'  therefore the total amount of rounds for the selected user.
#'@seealso \code{\link{powerful_function}} allows you to run this and any other
#'  function in this package for more than one user.
#'
#'@family get functions
#'
#' @examples
#' get_rounds_by_ID(example_data, userid = 6) # Example return: [1] 0 1 2 3 4 5 6 7 8
#' get_rounds_by_ID(as.data.frame(matrix_full), 1200) # If userid given not found in the given data(x) function returns: integer(0).
#'
#'@export

get_rounds_by_ID <- function(x, userid = NULL) {
  if(is.null(userid)) {
    stop("You need to specify one userid.")
  }
  ## Check if given userid is in the data
  if(!userid %in% get_all_userids(x)) {
    print(userid)
    stop("The userid you specified is not contained in your data.")
  }

  table_by_ID <- get_table_by_ID(x, userid)
  result <- unique(table_by_ID$round)
  result
}

#' Get all user IDs
#'
#' Allows you to get all the user IDs in your data. It assumes you have a column
#' \code{$usid} that identifies each user's information of each round with its
#' corresponding user ID. Returns IDS unordered, i.e. in the order they appear
#' on the table.
#'
#' @param dataset the data.frame you want to input.
#'
#' @return a vector of integers with all user IDs. IDs are returned in the order
#'   they appear on the table.
#'
#' @family get functions
#' @examples
#' get_all_userids(example_data) #Example return: [1] 1 2 3 4 5  # ordered userids.
#' get_all_userids(data) #Example return: [1] 6 9 10 8 6 2 4  # returns IDs just as they are on the given table.
#'
#' @references ProductConfig Github page:
#'   https://github.com/avilesd/productConfig
#' @export

get_all_userids <- function(dataset) {
  table_unique <- sapply(dataset, unique)
  result <- table_unique$usid
  result
}
#'Get Default Reference Points for selected user
#'
#'With Default Referenece Points we mean the initial configuration of the
#'product configurator, that is the value for each attribute that was selected
#'as default before the user interacted with the configurator. It assumes there
#'is a column with the name 'round' from which to read the default values (in
#'round = 0) for each user. The  The default values of each 'category' can be
#'interpreted as possible Reference Points for the decision maker. See Source
#'for more about this assumption.
#'
#'@param dataset the data.frame you want to analyze. For the default values for
#'  more or all users, see \code{\link{powerful_function}}
#'@param user_id an integer, that identifies which rows (from which user) of the
#'  whole given dataset should be extracted.
#'
#'@return A numeric vector with column names representing the attribute ID each
#'  reference point belongs to.
#'
#'@seealso \code{\link{powerful_function}} allows you to run this and any other
#'  function in this package for more than one user.
#'@family get functions
#' @examples
#' get_all_default_rps(camera2_config_data, 100)
#' get_all_default_rps(as.data.frame(matrix_full), 55)
#'@export
get_all_default_rps <- function(dataset, userid) {
  if(is.null(userid)) {
    stop("You need to specify one userid.")
  }
  ## Check if given userid is in the data
  if(!userid %in% get_all_userids(dataset)) {
    print(userid)
    stop("The userid you specified is not contained in your data.")
  }

  table_unique <- get_table_by_ID(dataset, userid)
  table_0 <- table_unique[table_unique$round == 0, ]
  result <- table_0$selected

  ##Give Reference Points names according to attribute they belong to
  m <- 1
  help <- get_attrs_ID(dataset)
  rp_names <- character(0)

  for(rp in result){
    rp_number <- help[m]
    rp_names <- c(rp_names, paste("rp", rp_number, seq="", collapse=""))
    m <- m + 1
  }
  names(result) <- rp_names

  result

}

#' Normalize a vector
#'
#' Divide all given vectors with the absolute sum of all the elements in the
#' vector, such that the sum of the result equals 1, that is if you take the
#' absolute value of the results. In other words, you can give negative values.
#'
#' @param num_vector numeric vector you want to normalize.
#'
#' @return A normalized vector, i.e. anothernumeric vector with the sum of its
#'   absolute values equaling 1.
#'
#' @family get functions
#' @examples
#' get_normalized_vec(c(1,2,1,2)) #Returns: [1] 0.1666667 0.3333333 0.1666667 0.3333333
#' get_normalized_vec(c(1,2,1,-2)) #Returns: [1] 0.1666667 0.3333333 0.1666667 -0.3333333
#'
#' @references ProductConfig Github page:
#'   https://github.com/avilesd/productConfig
#' @export

get_normalized_vec <- function(num_vector) {
  if(is.vector(num_vector, mode="numeric")) {
    sum <- sum(abs(num_vector))
    result <- num_vector/sum
    result
  }
  else warning("Entered argument not a numeric vector.")
}

#' All unique values for a given attribute
#'
#' Returns all unique values that can be found in the given attribute, i.e. all
#' values that exist for \code{attrid} for all users.
#'
#' @param dataset complete data.frame with a \code{atid} column referring to the
#'   attribute ID.
#' @param attrid the ID of the attribute you want to know all unique values of.
#'
#' @return Unique values for the given attribute, applies for all users.
#'
#' @family get functions
#' @examples
#' get_attr_values(example_data, attrid=1) # Example return: [1] 0 3 2 1 meaning that category only has 4 possible values in the product configutrator, or at least those were the ones the users clicked on
#' get_attr_values(other_data, 100) #Possible catched error: The attrID you specified is not contain in your data.
#'
#' @export

get_attr_values <-function(dataset, attrid = NULL) {
  if(is.null(attrid)) {
    stop("You need to specify one attrid")
  }
  if(is.null(dataset)) {
    stop("You need to provide the dataset")
  }
  ## Check if given userid is in the data
  if(!attrid %in% get_attrs_ID(dataset)) {
    print(attrid)
    stop("The attrid you specified is not contained in your data.")
  }

  help1 <- tapply(dataset$selected, play_data$atid == attrid, unique)
  result <- help1$'TRUE'
  result
}

