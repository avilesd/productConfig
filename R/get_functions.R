#' Extract the part of the provided dataset that corresponds to a user id.
#'
#' With user_id you select the rows from one user, all given columns of x remain intact for that user. We assume the given dataset was generated by data from a product configuration,
#' and therefore has as one column the user id. Other columns may include, but not limited to, attribute IDs, round,
#' selected attribute and selectable attribute.
#'
#' @param x the data.frame (table) you want to separate in a smaller data.frame for a specific user. For more users at once see \code{\link{powerful_function}} or manually.
#'
#' @param user_id an integer, that identifies which rows (from which user) of the whole given dataset should be extracted.
#' @return A data.frame with the same columns as the original, but only with rows about the provided \code{user_id}.
#' @seealso \code{\link{powerful_function}} allows you to run this and any other function in this package for more than one user.
#' @examples
#' get_table_by_ID(camera2_config_data, 9)
#' get_table_by_ID(as.data.frame(matrix_full), 12)

get_table_by_ID<- function(x, userid,...) {
  result <- x[x$usid == userid, ]
  result
}

#' Get the amount of attributes and their IDs
#'
#' Allows the user to know how many different attributes there are in the data.frame or table. The number of attributes comes directly
#' from the number of categories that a user can manipulate in a given product configurator. The function assumes that all attribute IDs are in a single column
#' with the name \code{$atid}. It also assumes, that all users interacted with the same amount of attributes.
#'
#' @param x the data.frame you want to input.
#'
#' @return a vector of integers representing all existing attribute IDs.
#' @examples
#' get_attrs_ID(my_data) #Example return: [1] 1 2 3 4 , meaning there are 4 attributes on my_data with ascending indexes.
#' get_attrs_ID(bad_data) #Warning: Attributes IDs should only be integers.
#' @references ProductConfig Github page: https://github.com/avilesd/productConfig
#' @export
#'

get_attrs_ID<- function(x) {
  help <- lapply(x, unique)
  result <- help$atid

  if(!is.vector(result) & class(result) != "integer") {
    warning("Result of function not a vector of integers, attributes IDs should only be integers.")
  }

  result
}

#' Get the amount of rounds (clicks) for one user
#'
#' Allows to calculate the amount of times a user interacted with the product configurator, i.e. amount of clicks for the given user ID.
#' The given data.frame should signalize with a column named 'round', which should only contain numbers.
#'
#' @param x the complete data.frame. You can also input the data.frame specific for one user, such as the one generated with \code{\link{get_table_by_ID}}. For more users at once see \code{\link{powerful_function}} or manually.#'
#' @param user_id an integer, that identifies which rows (from which user) of the whole given dataset should be extracted.
#'
#' @return An integer vector representing the index of each round/click and therefore the total amount of rounds for the selected user.
#' @seealso \code{\link{powerful_function}} allows you to run this and any other function in this package for more than one user.
#' @examples
#' get_rounds_by_ID(example_data, userid = 6) # Example return: [1] 0 1 2 3 4 5 6 7 8
#' get_rounds_by_ID(as.data.frame(matrix_full), 1200) # If userid given not found in the given data(x) function returns: integer(0).
#'
get_rounds_by_ID <- function(x, userid) {
  table_by_ID <- get_table_by_ID(x, userid)
  result <- unique(table_by_ID$round)
  result
}

#' Get all user IDs
#'
#' Allows you to get all the user IDs in your data. It assumes you have a column \code{$usid} that identifies each user's information of each round with its corresponding user ID.
#' Returns IDS unordered, i.e. in the order they appear on the table.
#'
#' @param x the data.frame you want to input.
#'
#' @return a vector of integers with all user IDs. IDs are returned in the order they appear on the table.
#' @examples
#' get_all_userids(example_data) #Example return: [1] 1 2 3 4 5  # ordered userids.
#' get_all_userids(data) #Example return: [1] 6 9 10 8 6 2 4  # returns IDs just as they are on the given table.
#'
#' @references ProductConfig Github page: https://github.com/avilesd/productConfig
#' @export

get_all_userids <- function(dataset) {
  table_unique <- sapply(play_data, unique)
  result <- table_unique$usid
  result
}
#' Get Default Reference Points for selected user
#'
#' With Default Referenece Points we mean the initial configuration of the product configurator, that is the value for each attribute that was selected as default before the
#' user interacted with the configurator. It assumes there is a column with the name 'round' from which to read the default values (in round = 0) for each user. The  The default values of each 'category' can be interpreted as possible Reference Points for the decision maker. See Source for more about this assumption.
#'
#' @param x the data.frame you want to analyze. For the default values for more or all users, see \code{\link{powerful_function}}
#' @param user_id an integer, that identifies which rows (from which user) of the whole given dataset should be extracted.
#' @return A numeric vector with column names representing the attribute ID each reference point belongs to.
#' @seealso \code{\link{powerful_function}} allows you to run this and any other function in this package for more than one user.
#' @examples
#' get_all_default_rps(camera2_config_data, 100)
#' get_all_default_rps(as.data.frame(matrix_full), 55)
#'
get_all_default_rps <- function(dataset, userid) {
  table_unique <- get_table_by_ID(dataset, userid)
  table_0 <- table_unique[table_unique$round == 0, ]
  result <- table_0$selected

  ##Give Reference Points names according to attribute they belong to
  m <- 1
  help <- get_attrs_ID(dataset)
  rp_names <- character(0)

  for(rp in result){
    rp_number <- help[m]
    rp_names <- c(rp_names, paste("rp", rp_number, seq="", collapse=""))
    m <- m + 1
  }
  names(result) <- rp_names

  result

}

get_normalized_vec <- function(num_vector) {
  if(is.vector(num_vector, mode="numeric")) {
    sum <- sum(num_vector)
    result <- num_vector/sum
    result
  }
  else warning("Entered argument not a numeric vector.")
}


# This is just a funcion that I wrote here to not forget the code, could be useful, but right now is not fundamental.
read_attr_levels <-function(x) {
  help1 <- tapply(x$selected, play_data$atid == 4, unique)
  result <- help1$'TRUE'
  result
}


## To be use for weights.
#'
#' @param rel_frequeny logical. Relative frequency, if \code{rel_frequency = TRUE}, the function ignores the refps argument
#'        and calculates the aspiration level for each attribute as the relative frequency the user made for that attribute.
#'
#' ###to consider, defaults considers all your attributes in your table and calculates with relative frequency of the attributes
#' if no other weights are given. ##no userid because weights independent from user
#'
get_attr_weight <- function(dataset) {
  if(is.null(dataset) ) {
  refps <- get_all_default_rps(dataset, userid)
  ##TODO calculate relative frequency, see annotations notebook
  }
  ## TODO proove if length(w) =length(attributes), proof if numeric and the sum of all = 1!!!
  else{
    weight
  }
}

