% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DRPFunctions.R
\name{dualValueMatrix}
\alias{dualValueMatrix}
\title{Returns a Value Matrix using two reference points}
\usage{
dualValueMatrix(dataset, userid = NULL, attr = NULL, rounds = NULL,
  cost_ids = NULL, dual.refps = c(sq = NA, g = NA), lambda = 2.25,
  delta = 0.8, consumption_fun = NULL)
}
\arguments{
\item{dataset}{data.frame with the user generated data from a product
configurator. See \code{decisionMatrix} for specifications of the dataset.}

\item{userid}{a vector of integers that gives the information of which users
the matrix should be calculated. Vectorised.}

\item{attr}{attributes IDs, vector of integer numbers corresponding to the
attributes you desire to use; \code{attr} are assumed to be 1-indexed.}

\item{rounds}{integer vector or text option. Which steps of the configuration
process should be shown? Defaults are first and last step. Text options are
\code{all, first, last}.}

\item{cost_ids}{argument used to convert selected cost attributes into
benefit attributes. Integer vector.}

\item{dual.refps}{numeric - two numbers indicating the status-quo and the
aspiration level(goal) for the given attributes. Status-quo should always
be the first input.}

\item{lambda}{numeric - parameter of loss aversion for the value function as
given by reference[1]. Default value is 2.25 as in [2] and should be
\code{lambda > 1}.}

\item{delta}{numeric - expresses the relative importance of the aspiration
level to other factors. Default is 0.8 and it should satisfy \code{0 <
delta <1}.}

\item{consumption_fun}{non-working parameter for future developments. Leave
at NULL.}
}
\value{
a list of value matrices for each user.
}
\description{
This function is based on the value function of the dual reference point
(dual-rp) models, as seen in reference 1 (Golman, Loewenstein). It first
builds a desicion matrix for each user and then applys the 'utility function'
over each value using two given reference points (SQ, G). It does so by
calling the function \code{\link{smallerThanZero}}. The dual-rp utility
function works in two steps, much like prospect theory's value function
\code{\link{overallPV},\link{pvMatrix}} See details and references.
}
\details{
Note that since the dual-rp value function uses a logarithmic
  function, attribute values and reference points should be larger than zero.
  Nontheless, if this function detects a zero or negative value it will
  monotonically scale your data and your reference points so that for all
  applies \code{x > 0}. The transformation does not have an impact on the
  absolute differences between attribute values and reference points.

  This function only makes sense to use with multiple attributes if those
  attributes have exactly the same two reference points (sq, g). Therefore
  you will have to manually calculate all the value matrices for the
  different attributes (with different values) and cbind them together using
  mapply. The full matrix can then be given as an input to the
  \code{\link{overallPV_interface}} fucntion to calculate the overall
  prospect values for each round.

  \code{data} We assume the input data.frame has following columns usid =
  User IDs, round = integers indicating which round the user is in (0-index
  works best for 'round'), atid = integer column for referring the attribute
  ID (1 indexed), selected = numeric value of the attribute for a specific,
  given round, selectable = amount of options the user can chose at a given
  round, with the current configuration.

  \code{userid} is a necessary parameter, without it you'll get a warning.
  Default is NULL.

  \code{attr} Default calculates with all attributes. Attributes are
  automatically read from provided dataset, it is important you always
  provide the complete data so that the package functions properly. Moreover,
  \code{userid} and \code{attr} will not be sorted and will appear in the
  order you input them.

  \code{rounds} Default calculates with first and last rounds (initial and
  final product configuration). You can give a vector of arbitrarily chosen
  rounds as well.

  \code{cost_ids} Default assumes all your attributes are of benefit type,
  that is a higher value in the attribute means the user is better off than
  with a lower value. If one or more of the attributes in your data is of
  cost type, e.g. price, so that lower is better then you should identify
  this attributes as such, providing their id, they'll be converted to
  benefit type (higher amount is better).

  \code{delta} [1] Initially called alpha, we chose delta to avoid confusion
  with prospect theory's parameter for concavity, such as seen in
  \code{\link{overallPV}}

  Note: When converting a cost attribute to a benefit attribute its two
  reference points change as well, enter the unconverted dual.refps, the
  function transforms them automatically when it detects a \code{cost_ids !=
  NULL}.
}
\examples{
dualValueMatrix(pc_config_data, 9:10, dual.refps = c(1, 3.5))
dualValueMatrix(aDataFrame, userid = 100, rounds = "all", dual.refps = c(1, 2))
dualValueMatrix(myData, userid = 11, attr = c(1,3,5), cost_ids = 2) #Input accepted but cost_ids = 2 will be ignored
dualValueMatrix(myData, userid = 11, attr =  1, cost_ids = 1, dual.refps = c(8, 2)) # Note that for cost attributes:  SQ > G
dualValueMatrix(keyboard_data, 60, rounds = "first", attr = 1, dual.refps = c(1, 2), lambda = 5, delta = 0.5)
dualValueMatrix(data1, 2) # Returns an error since no reference points given

}
\references{
[1] Golman, R., & Loewenstein, G. (2011). Explaining Nonconvex
  Preferences with Aspirational and Status Quo Reference Dependence. Mimeo,
  Carnegie Mellon University.

  [2] Tversky, A., & Kahneman, D. (1992). Advances in prospect theory:
  Cumulative representation of uncertainty. Journal of Risk and uncertainty,
  5(4), 297-323.
}

